5如何解释Erlang崩溃转储

本节描述在Erlang运行时系统异常退出时生成的 erl_crash.dump 文件。

注意
Erlang崩溃转储在Erlang / OTP R9C中进行了重大改进。 因此，本节中的信息不适用于较旧的转储。 但是，如果在旧转储上使用 crashdump_viewer(3) ，则会将故障转储转换为与此类似的格式。

系统将故障转储写入模拟器的当前目录或环境变量指示的文件中（无论在当前操作系统上是什么意思） ERL_CRASH_DUMP 。 要写入故障转储，必须安装可写文件系统。

崩溃转储主要是出于以下两个原因之一编写的：内置函数 erlang:halt/1 是使用运行Erlang代码的字符串参数显式调用的，或者运行时系统检测到无法处理的错误。 系统无法处理错误的最常见原因是原因是外部限制，例如内存不足。 由内部错误引起的故障转储可能是由于系统在仿真器本身达到限制（例如系统中的原子数或太多同时的ETS表）而引起的。 通常可以重新配置仿真器或操作系统以避免崩溃，这就是为什么正确解释故障转储很重要的原因。

在支持OS信号的系统上，还可以通过发送 SIGUSR1 信号来停止运行时系统并生成故障转储。

Erlang崩溃转储是一个可读的文本文件，但可能很难阅读。 使用 Observer 应用程序中的Crashdump Viewer工具简化了任务。 这是一个基于wx-widget的工具，用于浏览Erlang崩溃转储。

5.1一般信息
崩溃转储的第一部分显示以下内容：

转储的创建时间
一个标语，说明转储的原因
转储源自的节点的系统版本
运行源节点的仿真器的编译时间
原子表中的原子数
导致崩溃转储的运行时系统线程
崩溃转储的原因（口号）
转储的原因显示在文件的开头：

Slogan: <reason>
如果系统被BIF erlang:halt/1 ，则口号是传递给BIF的字符串参数，否则它是由模拟器或（Erlang）内核生成的描述。 通常，该消息足以理解该问题，但此处描述了一些消息。 请注意，建议的崩溃原因 只是建议 。 错误的确切原因可能因本地应用程序和底层操作系统而异。

<A>：无法分配<N>个字节的内存（类型为“<T>”）
系统内存不足。 <A>是无法分配内存的分配器，<N>是<A>尝试分配的字节数，<T>是需要内存的内存块类型。 最常见的情况是进程存储大量数据。 在这种情况下，<T>通常是 heap ， old_heap ， heap_frag 或 binary 。 有关分配器的更多信息，请参阅 erts_alloc(3) 。

<A>：无法重新分配<N>个字节的内存（类型为“<T>”）
与上面相同，除了在系统内存不足时重新分配内存而不是分配内存。

意外的操作码<N>
编译代码出错， beam 文件损坏或编译器出错。

模块<名称>未定义 | 函数<Name> undefined | 无功能<名称>：<名称> / 1 | 无功能<名称>：开始/ 2
内核/ STDLIB应用程序已损坏或启动脚本已损坏。

Driver_select使用过大的文件描述符 N 调用
套接字的文件描述符数超过1024（仅限Unix）。 某些Unix风格的文件描述符限制可以设置为1024以上，但Erlang只能同时使用1024个套接字/管道（因为Unix select 调用的限制）。 打开常规文件的数量不受此影响。

收到SIGUSR1
将 SIGUSR1 信号发送到Erlang机器（仅限Unix）会强制执行故障转储。 这个口号反映出Erlang机器因接收到信号而崩溃。

内核pid终止（<Who>）（<退出原因>）
内核管理程序检测到故障，通常是 application_controller 已关闭（ Who = application_controller ， Why = shutdown ）。 应用程序控制器可能由于多种原因而关闭，最常见的是分布式Erlang节点的节点名称已在使用中。 完整的主管树“崩溃”（即顶级主管已退出）给出了相同的结果。 此消息来自Erlang代码，而不是来自虚拟机本身。 它总是因为应用程序中的一些失败，无论是在OTP内还是在“用户编写的”中。 查看应用程序的错误日志可能是第一步。

Init终止于do_boot（）
原始的Erlang引导序列终止，很可能是因为引导脚本有错误或无法读取。 这通常是配置错误; 系统可以使用fault--boot参数启动，也可以使用错误的OTP版本的启动脚本启动。

无法启动内核pid（<Who>）（）
其中一个内核进程无法启动。 这可能是因为错误的参数（如 -config 参数中的错误）或错误的配置文件。 检查所有文件是否位于正确的位置，以及配置文件（如果有）是否已损坏。 通常，消息也会写入控制终端和/或错误日志，说明错误。

可能会出现其他错误，因为 erlang:halt/1 BIF可以生成任何消息。 如果消息不是由BIF生成的，并且在上面的列表中没有出现，则可能是因为模拟器中的错误。 然而，可能存在未提及的异常消息，这些消息仍然与应用程序故障相关联。 有更多可用信息，因此彻底阅读崩溃转储可以揭示崩溃原因。 进程的大小，ETS表的数量以及每个进程堆栈上的Erlang数据可用于查找问题。

原子数
崩溃时系统中的 原子数 显示为 Atoms：<number> 。 大约一万个原子是完全正常的，但更多可以表明BIF erlang:list_to_atom/1 用于动态生成许多 不同的 原子，这绝不是一个好主意。

5.2调度程序信息
在tag = scheduler 下显示有关运行时系统中调度程序的当前状态和统计信息的信息。 在允许暂停其他线程的操作系统上，此部分中的数据反映了崩溃发生时运行时系统的外观。

进程可以存在以下字段：

=调度：ID
标题。 说明调度程序标识符。

调度程序睡眠信息标志
如果为空，则调度程序正在做一些工作。 如果不为空，则调度程序处于某种睡眠状态或暂停状态。 此条目仅存在于启用SMP的仿真器中。

调度程序睡眠信息辅助工作
如果不为空，则计划完成调度程序内部辅助工作。

当前港口
调度程序当前执行的端口的端口标识符。

当前流程
调度程序当前执行的进程的进程标识符。 如果存在这样的过程，则该条目之后是该过程的 州 ， 内部州 ， 程序计数器 和 CP 。 条目在“ Process Information 部分中描述。

请注意，这是开始生成故障转储时条目的准确快照。 因此，它们很可能与 = proc 部分中找到的相同进程的条目不同（并且更有说服力）。 如果当前没有正在运行的进程，则仅显示 当前进程 条目。

当前流程限制堆栈跟踪
仅当存在当前进程时才显示此条目。 它类似于 =proc_stack ，只是显示了功能框（即，省略了堆栈变量）。 此外，仅显示堆栈的顶部和底部。 如果堆栈很小（<512个插槽），则显示整个堆栈。 否则，将显示 跳过## slots 的条目，其中 ## 被已跳过的插槽数替换。

运行队列
显示有关在此调度程序上安排了多少个不同优先级的进程和端口的统计信息。

**坠毁**
此条目通常不会显示。 它表示由于某种原因获取有关此调度程序的其余信息失败。

5.3内存信息
在tag = memory下面 显示的信息类似于使用 erlang:memory() 在生命节点上可以获得的信息。

5.4内部表信息
在tags = hash_table：<table_name> 和 = index_table下：<table_name> 显示内部表。 这些主要是运行时系统开发人员感兴趣的。

5.5分配区域
在tag = allocated_areas 下显示的信息类似于可以在具有 erlang:system_info(allocated_areas) 的生命节点上获得的信息。

5.6分配器
在tag = allocator下：<A> 显示有关分配器<A>的各种信息。 该信息类似于可以在具有 erlang:system_info({allocator, <A>}) 的生命节点上获得的信息 erlang:system_info({allocator, <A>}) 。 有关更多信息，另请参阅 erts_alloc(3) 。

5.7过程信息
Erlang crashdump包含系统中每个生存Erlang进程的列表。 进程可以存在以下字段：

= PROC：<PID>
标题。 说明进程标识符。

州
过程的状态。 这可以是以下之一：

计划
该进程已安排运行但当前未运行（“在运行队列中”）。
等候
这个过程正在等待（ receive ）。
运行
该流程目前正在运行。 如果调用了BIF erlang:halt/1 ，那么这就是调用它的过程。
退出
这个过程正在退出。
Garbing
这是运气不好，在写入崩溃转储时，进程是垃圾收集。 此过程的其余信息有限。
暂停
该进程暂停，可以是BIF erlang:suspend_process/1 ，也可以是因为它尝试写入忙碌端口。
注册名称
流程的注册名称（如果有）。

产卵了
进程的入口点，即在启动进程的 spawn 或 spawn_link 调用中引用了什么函数。

最后安排在| 目前的电话
该过程的当前功能。 这些字段并不总是存在。

产卵了
进程的父进程，即执行 spawn 或 spawn_link 的进程。

入门
流程开始的日期和时间。

消息队列长度
进程'消息队列中的消息数。

堆片段数
分配的堆片段数。

堆片段数据
碎片堆数据的大小。 这是由发送到进程的消息或Erlang BIF创建的数据。 这个数量取决于很多事情，这个领域完全无趣。

链接列表
与此链接相关的进程的进程ID。 也可以包含端口。 如果使用过程监控，则此字段还会告知监控的生效方向。 也就是说，一个“到”一个进程的链接告诉你“当前”进程正在监视另一个进程，并且一个进程的“链接”告诉你另一个进程正在监视当前进程。

排量
流程消耗的减少数量。

栈+堆
堆栈和堆的大小（它们共享内存段）。

OldHeap
“旧堆”的大小。 Erlang虚拟机使用两代的分代垃圾收集。 新数据项有一个堆，而两个垃圾收集中存活的数据有一个堆。 这个假设（几乎总是正确的）是两个垃圾收集中存活的数据可以“老化”到堆中，很少收集垃圾，因为它们将存活很长时间。 这是虚拟机中的常用技术。 堆和堆栈的总和一起构成了进程的大部分分配内存。

堆未使用，OldHeap未使用
每个堆上未使用的内存量。 这些信息通常是无用的。

记忆
此进程使用的总内存。 这包括调用堆栈，堆和内部结构。 与 erlang:process_info(Pid,memory) 相同 erlang:process_info(Pid,memory) 。

程序计数器
当前指令指针。 这只是运行时系统开发人员感兴趣的。 程序计数器指向的功能是进程的当前功能。

CP
延续指针，即当前调用的返回地址。 对于运行时系统开发人员以外通常无用。 这之后可以是CP指向的函数，即调用当前函数的函数。

元数
活动参数寄存器的数量。 参数注册是否有任何现场将遵循。 如果它们尚未移动到堆栈，它们可以包含函数的参数。

内部国家
更详细的内部表示此过程的状态。

另请参见 =proc_stack 部分。

5.8港口信息
本节列出了开放端口，其所有者，任何链接的进程以及其驱动程序或外部进程的名称。

5.9 ETS表
本节包含有关系统中所有ETS表的信息。 每个表都对以下字段感兴趣：

= ETS：<所有者>
标题。 表所有者（进程标识符）。

表
表的标识符。 如果表是 named_table ，则这是名称。

名称
表名，无论是否为 named_table 。

哈希表，桶
如果表是哈希表，也就是说，如果它不是 ordered_set 。

哈希表，链长
如果表是哈希表。 包含有关表的统计信息，例如最大，最小和平均链长。 具有远大于平均值的最大值，并且远大于预期标准偏差的标准偏差表示由于某种原因，术语的散列表现很差。

有序集（AVL树），元素
如果表是 ordered_set 。 （元素的数量与表中的对象数相同。）

固定
如果使用 ets:safe_fixtable/2 或某些内部机制修复表。

对象
表中的对象数。

话
分配给表中数据的字数（通常为4字节/字）。

类型
表类型，即 set ， bag ， dublicate_bag 或 ordered_set 。

压缩
如果表被压缩了。

保护
保护表。

写并发
如果为表启用了 write_concurrency 。

读并发
如果为表启用了 read_concurrency 。

5.10定时器
本节包含有关使用 erlang:send_after/3 erlang:start_timer/3 启动的所有计时器的信息 erlang:start_timer/3 和 erlang:send_after/3 。 每个计时器都有以下字段：

=定时器：<所有者>
标题。 对计时器所有者（进程标识符）进行声明，即在计时器到期时接收消息的进程。

信息
要发送的消息。

剩下的时间
消息发送之前剩余的毫秒数。

5.11分发信息
如果Erlang节点处于活动状态，即设置为与其他节点通信，则此部分列出了活动的连接。 可以存在以下字段：

=节点：<节点>
节点名称。

no_distribution
如果节点未分发。

= visible_node：<通道>
标题为可见节点，即与崩溃节点连接的活动节点。 说明节点的通道编号。

= hidden_​​node：<通道>
标题为隐藏节点。 隐藏节点与可见节点相同，只是它以 "-hidden" 标志启动。 说明节点的通道编号。

= not_connected：<通道>
标题为先前连接到崩溃节点的节点。 崩溃时存在未连接节点的引用（即进程或端口标识符）。 说明节点的通道编号。

名称
远程节点的名称。

调节器
控制与远程节点通信的端口。

创建
与节点名称一起的整数（1-3）标识节点的特定实例。

远程监控：<local_proc> <remote_proc>
本地进程在崩溃时监视远程进程。

远程监控：<local_proc> <remote_proc>
远程进程在崩溃时监视本地进程。

远程链接：<local_proc> <remote_proc>
崩溃时本地进程和远程进程之间存在链接。

5.12加载的模块信息
本节包含有关所有已加载模块的信息。

首先，汇总了加载代码的内存使用情况：

目前的代码
代码是当前最新版本的模块。

旧代码
代码中系统中存在较新版本但旧版本尚未清除。

内存使用以字节为单位。

然后，列出所有已加载的模块。 存在以下字段：

= MOD：<模块>
标题。 说明模块名称。

目前的规模
内存用于加载的代码，以字节为单位。

旧的尺寸
内存用于旧代码，如果有的话。

当前属性
当前代码的模块属性。 Crashdump Viewer工具查看时，此字段将被解码。

旧属性
旧代码的模块属性（如果有）。 Crashdump Viewer工具查看时，此字段将被解码。

当前的编译信息
当前代码的编译信息（选项）。 Crashdump Viewer工具查看时，此字段将被解码。

旧的编译信息
旧代码的编译信息（选项），如果有的话。 Crashdump Viewer工具查看时，此字段将被解码。

5.13有趣的信息
本节列出了所有的乐趣。 每个乐趣都有以下字段：

=乐趣
标题。

模
定义乐趣的模块的名称。

Uniq，Index
身份标识。

地址
乐趣代码的地址。

Native_address
启用HiPE时有趣代码的地址。

REFC
有趣的参考数量。

5.14过程数据
对于每个进程，至少有一个 = proc_stack 和一个 = proc_heap 标记，后跟进程的堆栈和堆的原始内存信息。

对于每个进程，如果进程消息队列非空，则还有一个 = proc_messages 标记;如果进程字典（ put/2 和 get/1 事件）非空，则还有一个 = proc_dictionary 标记。

Crashdump Viewer工具可以解码原始内存信息。 然后，您可以看到堆栈转储，消息队列（如果有）和字典（如果有）。

堆栈转储是Erlang进程堆栈的转储。 大多数实时数据（即当前使用的变量）都放在堆栈中; 因此这可能很有趣。 人们必须“猜测”什么是什么，但由于信息是象征性的，因此彻底阅读这些信息可能很有用。 作为示例，我们可以在以下示例中找到Erlang基元加载器的状态变量online (5) 和 (6) ：

(1)  3cac44   Return addr 0x13BF58 (<terminate process normally>)
(2)  y(0)     ["/view/siri_r10_dev/clearcase/otp/erts/lib/kernel/ebin",
(3)            "/view/siri_r10_dev/clearcase/otp/erts/lib/stdlib/ebin"]
(4)  y(1)     <0.1.0>
(5)  y(2)     {state,[],none,#Fun<erl_prim_loader.6.7085890>,undefined,#Fun<erl_prim_loader.7.9000327>,
(6)            #Fun<erl_prim_loader.8.116480692>,#Port<0.2>,infinity,#Fun<erl_prim_loader.9.10708760>}
(7)  y(3)     infinity    
在解释进程的数据时，知道匿名函数对象（funs）给出以下内容是有帮助的：

根据创建它们的函数名称构造的名称
一个数字（从0开始），表示该函数中的乐趣数
5.15原子
本节介绍系统中的所有原子。 如果人们怀疑原子的动态生成可能是个问题，那么这只是有意义的，否则这一部分可以被忽略。

请注意，最后显示的是最后创建的原子。

5.16免责声明
崩溃转储的格式在OTP版本之间发生变化。 此处描述的某些信息可能不适用于您的版本。 这样的描述永远不会完整; 它通常用于解释崩溃转储，并在尝试查找应用程序错误时提供帮助，而不是完整的规范。