# [Erlang -- 杂记]

1.回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方法直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。因为可以把调用者与被调用者分开，所以调用者不关心谁是被调用者。它只需知道存在一个具有特定原型和限制条件的被调用函数。简而言之，回调函数就是允许用户把需要调用的方法的指针作为参数传递给一个函数，以便该函数在处理相似事件的时候可以灵活的使用不同的方法。

打个简单的比方： 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。

2.-export的函数放在方括号里，一般有两类函数，一类是供外界调用的API函数，一类是gen_server的接口函数。一般会把这两类函数分开。exprot里的函数一般是模块外要引用的函数，如果只在本模块使用，则不用在export写明！

3.循环内不要出现断链的情况（返回false）。

4.if判定表达式中不能有函数。

5.推导公式的结果一定是[ ] 或[ X ]。

6._Err :如果不想用这个变量，可以在这个变量前加下划线（_）。

7.函数要引用函数里的变量。

8.if语句后面要添加true语句（只能填true语句，不能写**_**,不然编译器会报错），以增加代码的健壮性！case 不能用true，只能用_ ！！！

9.从数据库中取出的数据都是二进制，如果数据是string类型，那么在Erlang中格式为<< "">>,在Erlang的具体编程中会把这种二进制格式转化为string或[ ]这种格式，用bitstring_to_term()函数来实现，反过来在Erlang中如果要把string类型的或[ ]类型的数据存入数据库中，则一定要将string类型转化为<<"">>这种格式，才能被写入数据库，用term_to_bitstring()函数！

10.如果某种功能的执行能与其他的的进程并行处理，那么可以设计一个专门的进程用来处理这个功能，这样可以打打的提高效率。

11.call用cast实现的方法：A call B  等于 （ A cast B ，B执行操作，在这个过程中，A执行其他的操作，当B执行完后，B cast A，A 执行相应的操作。）

12.编程时把基本数据做成ETS的基本表，而对于用户表则作为记录形式就行。因为基础数据每个玩家都会用，而每个玩家都有自己的一个用户表，每个玩家的操作都在自己的用户表中进行。

13.当事务官属于玩家，没有必要去判定她在基础表中有没有记录，除非你要用到基础表中的数据。

14.rfc4627:decode(A)中A需要双引号，如果A数据中包含双引号，则需要转义。而rfc4627:encode(A)中的A不需要双引号。在encode函数中原子会自动转化为字符串形式。如A={obj,  [{material,[2000]},{targetLevel,12}，{needPower,52},{planetId,1}]}, rfc4627:encode(A). 结果为："{\"material\":   [2000],\"targetLevel\":12,\"needPower\":52,\"planetId\":1}"

15.绝对路径：是从盘符开始的路径，形如*C:\windows\system32\cmd.exe*

相对路径：是从当前路径开始的路径，假如当前路径为C:\windows，要描述上述路径，只需输入system32\cmd.exe，实际上，严格的相对路径写法应为.\system32\cmd.exe，其中，.表示当前路径，在通常情况下可以省略，只有在特殊的情况下不能省略。

16.从数据库中取出数据的格式是[ [],[],[]... ],而从ETS表中取出数据的格式是[ {},{},{}...]。

17.在MySQL中的varchar格式为[ 1,2,3],则在Erlang中则转换为bitstring:<<"[1,2,3]">>,bitstring(binary)  ---->list:"[1,2,3]",bitstring --->term:[1,2,3],bitstring是binary的一个子集。"[]"格式在存入数据库时会自动转化为<<"[]">>格式，所以无需转化。

在Erlang中的字符串格式和在MySQL中的不一样，在MySQL中的字符串格式如"abc",到Erlang中就转化为<<"abc">>

MySQL："abc" ---> Erlang：(bitstring)<<"abc">> ---->(list)"abc"  ，MySql：{1,2}  ----> Erlang : <<"{1,2}">> 

18.Erlang中的双引号字符串实际上就是列表，其元素就是该字符串中各字符的数值编码所对应的整数。如"abc" == [97,98,99] == [$a,$b,$c]

20.在编写程序的过程中一定要注意模式匹配，不仅有变量的模式匹配，如果变量可能有多个值，那么一定要考虑到所有的值的可能性，还有符号的模式匹配，如[]和{}等。

21.foldl函数的用法：foldl(Fun,Acc0,List) -> Acc1,如果Fun(X,Acc) -> B end , List中的元素一次绑定X，Acc的初始值为Acc0，B的返回值一定是Acc格式，如果B是函数，如B = reduce_material(X,Acc),在这里有一种很重要的用法，就是原子的用法。当X的变量为{ Type，_ ..}格式，那么可以编写多个reduce_material()函数，而用原子来判定用哪个reduce_material函数。注意：在foldl中Acc0、Acc以及foldl函数的返回值都是一样的格式！！！

22.在Erlang中，原子是一种仅由字符序列来标识的特殊字符串常量，因此两个原子只要具有相同的字符表示，就完全等同，但在系统内部，这些字符串存放在某张表内，并由表的下标定位，因此在运行时只要比较两个小整数就可以判断两个原子是否相等。每个原子也仅占一个字长的内存。特定原子的下标是在运行时自动分配的，但系统每次运行的时候分配的下标可能不同，用户无从知晓，也无须知晓。通常情况下，原子以小写字母开头，但在首字母之后，也可以使用大写字母、数字、下划线和@，如果还要用到其他字符，你就得给它们加上单引号。'a' == a : 原子a与原子'a'匹配。

23.命名的技巧：命名不能超过4个单词，极限是4个单词，一般2个、3个比较合理，函数名：动词+名词 ，如setData、doAction、changeScene；变量：名词或形容词，变量名最好是有类型后缀，如nameTXT、priceNum，所有的布尔类型都得有介词，如isOK、isEnabled 。

24.Erlang变量最显著的特点就在于变量名必须以大写字母开头！，而原子则必须以小写字母开头，在变量名中的单词以驼峰体隔开，变量名也可以以下划线开头。这种情况下，按常规第二个字符通常应该是大写字母，如_Err。赋值之后一直未被使用的变量往往会触发编译警告。然而，如果使用某个变量的目的仅在于提高程序的可读性，你可以在变量名前加上一个下划线，这样一来即便这些变量不被使用，编译器也不会报警，同时，所有未被使用的变量都会被优化掉。

25.erlang:is_record(term,RecordTag) -> boolean()，如果正确则返回true，否则返回false。

26.[list_to_tuple([ets_role|X]) || X<- []] == [].

27.self()函数能告诉你当前进程（即调用self()的那个进程）的pid，shell本身也是一个Erlang进程