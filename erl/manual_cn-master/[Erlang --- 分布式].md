# [Erlang --- 分布式]

erlang的分布式是以Erlang的两个基本特性为基础：

1.复制式进程通信    

Erlang的进程间通信采用的是严格的异步消息传递（发送消息后无须等待网络上的确认），接受方收到数据时实际上获取了数据的一份独立的副本；此后接收方将无法感知发送方对数据所做的任何操作，反之亦然。后续的任何通信都必须借助额外的消息才能进行。无论是运行在同一台机器上的进程，还是运行在不同机器上并通过网络互联的进程，这种模型都非常奏效。                                         

2.位置透明性

！（bang）运算符具有位置透明的属性——接收方在那台机器上并不重要，指引消息走向的信息统统都隐含在进程标识符之中了。Erlang会确保进程标识符在多机网络上的唯一性。

节点与集群

被配置成按分布式模式运行的Erlang VM（Erlang VM 指的就是运行时系统）就叫做节点。每个节点都有一个节点名，其他节点可以通过这个名字来找到该节点并与之通信，当前本地节点的节点名可以通过内置函数node()获取，节点名是个原子，格式为nodename@hostname。（不以分布式模式运行的VM的节点名恒为nonode@nohost）,在单台主机上可以同时运行多个节点。(nodename@Ip )

一旦两个或两个以上的Erlang节点能够相互感知，我们就说它们形成了一个集群。默认情况下，Erlang集群是一个全联通网络（集群中的每个节点都能够感知其他所有节点，任意两个节点都可以直接通信）。

3.节点的启动

只要给erl(或werl)加上命令行参数-name或-sname，就可以以分布式模式启动Erlang节点。

第一种形式：适用于配有DNS的普通网络环境，你需要给出节点的完全域名，如 erl -name simple_cache，

第二种形式：适用于完全限定域名不可用的情况，只要所有节点同处一个子网，你就可以使用短节点名。如 erl -sname simple_cache

注意：采用短节点名和长节点名的节点所处的通信模式是不同的，它们之间无法形成集群。只有采用相同模式的节点才能互联。

当Erlang VM以节点形态运行时，shell提示符中会包含节点名，如(simple_cache@mybox.home.net)1>

4.节点的互联

(1)、Erlang集群由两个或两个以上的节点组成。就数量而言，如果同一个集群内启动过多的节点的话，会有问题，因为维系机器之间的联络是需要一定的通信开销的，而Erlang集群又是一个全联通网络，这样一来这部分开销会随节点数的增加按平方规模增长。

(2)、借助一些特殊的节点，我们可以将多个集群合并成更大的、非全联通的集群，这类节点经过特殊的配置，不会对外传播其他节点的信息，它们甚至可以对其他节点隐身，以便对集群进行非侵入式监控。

(3)、一个节点不会主动搭理其他节点。你必须给它们一个呼朋唤友的理由；然而一旦探测到了别的节点，它便会持续追踪它们并与之交换已经和自己建立了连接的其他节点的信息，从而促成全联通网络的形成。

(4)、节点的互联，如果只是要建立连接，最简单的方法就是采用标准库函数net_adm:ping/1,例如:net_adm:ping('b@box.home.net'),通信成功就返回原子pong，否则就会返回原子pang。

(5)、如果在所有节点同处一台机器的情况下这一步仍然走不通，那么很可能是因为你采用了完全限定域名，却又没有配置好DNS，如果节点连不上，清用-sname代替-name再试试看。

5.EPMD

EPMD(Erlang Port Mapper Daemon)代表Erlang端口映射后台进程，你每启动一个节点，它都会检查本地机器上是否运行着EPMD，如果没有，节点就会自动启动EPMD。EPMD会追踪在本地机器上运行的所有节点，并记录分配给它们的端口。当一台机器上的Erlang节点试图与某远程节点通信时，本地EPMD就会联络远程机器上的EPMD(默认使用TCP/IP,端口为4369)，询问在远程机器上有没有叫相应名字的节点，如果有，远程的EPMD就会回复一个端口，通过该端口便可直接与远程节点通信，不过EPMD不会主动搜寻其他EPMD——只有在某个节点主动搜寻其他节点时通信才能建立。

6.magic cookie安全系统

(1)、Erlang的分布式功能配备了一套基于magic cookie的认证系统，撇开防火墙因素，最常见的导致节点连接失败的原因就是cookie设置错误。在shell中可以用auth:get_cookie()命令检查当前Erlang节点的cookie。

(2)、Erlang节点只有在知晓其他节点的magic cookie的情况下才能与它们通信。节点在启动时会尝试读取erlang.cookie文件，如果文件存在，它就会拿文件中的字符串当作自己的magic cookie。如果找不到，节点会新建一个cookie文件并写入一个随机字符串——这就是cookie文件最初的来历。

默认情况下，每个节点都会假定所有与自己打交道的节点都拥有和自己一样的cookie，除erlang.cookie文件所有者以外的其他用户只应拥有该文件的读权限。

(3)、对于更复杂的配置，你也可以借助内置函数set_cookie(Node,Cookie)通过编程手段来设置cookie，采用这种方式，节点可以用不同的cookie与不同的节点通信，原则上说，集群中每个节点的cookie都可以不同，但在实践中整个系统往往会共用一个cookie。

7.互联节点间的消息传递

节点是一个平台，节点上可以运行多个进程。

进程表示<X,Y,Z>：如果是本地进程，那么X=0，如果是非本地进程，那么X != 0

如果向某节点的某进程发送消息，直接用该进程的pid就行，无需指明进程所在的节点，因为目标节点的位置信息已经隐含在pid中了。

 

节点之间通信一般有三种方法

1、使用 !，比如 Pid ! "thanks"

2、使用rpc:call/cast[
](http://dhq.me/erlample/modules/rpc/call_5.html?search=rpc&i=2)

3、使用gen_server:call/cast

这里注意在Erlang中的pid，在Erlang中pid是唯一的，不管这个进程在不在同一个节点上，所以如果知道一个进程的pid，那么就可以通过这个pid找到这个进程，即使在不同的节点上，都可以使用gen_server:call/cast调用其他节点上的函数。

关于rpc的用法，可以查询相关资料。